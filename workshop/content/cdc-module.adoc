In this module you discover how you can leverage Change Data Capture to build out new functionality with minimal impact on existing applications.

== Business context

As mentioned in the introduction module (TODO: insert link) of the workshop, Globex went through a first modernization phase for their retail web application, moving from a legacy monolith to a containerized application.
Now the business would like to introduce new functionality: they want to introduce a cashback program, rewarding users buying products through the web site. For every purchase, the user would get a small percentage of the total order value as a cashback that they can use on follow-up orders. 

== Technical considerations

There are a lot of ways to approach this new requirement. The most straightforward would be to build the cashback functionality directly into the Globex retail application. After all, since the modernization of the application, it should be a lot easier to add new functionality compared to the days of the legacy app, when it could easily take several months to bring new functionality into production.
However, the technical teams are reluctant to add major new functionality to the Globex application, for fear of ending up again with a complex, hard to maintain and hard to deploy application. They very much prefer a microservices approach, where new functionality is added as a separate set of services which can be developed, deployed and maintained independently.

The cashback service will need access to the information of the orders made through the retail web site, which is stored in the retail app's database. A possible solution could consist in a microservice that polls the order tables at regular interval, extracts new orders and calculates and stores earned cashback.

There are a number of issues with this approach. First, in a microservices architecture, it is considered poor practice if a service connects directly into a database owned by another service, as this tends to tightly couple the different services together.
Also, the technical teams would prefer a more reactive approach, where the cashback service would be triggered every time an order is created or modified, rather than having to poll the database or call an API at regular intervals.

This is where Change Data Capture comes in.

== Change Data Capture

TODO: introduction to change data capture and Debezium.

== Cashback Service Architecture

TODO: detail the proposed architecture of the Cashback Service.

== Cashback Service Implementation

In the next chapter, you will be guided through the implementation and deployment of the Cashback service. Of course this entails way more than can be achieved during a workshop, so instead most components are already in place, and you will focus on a couple of key activities to deploy and run the solution.
